#!/usr/bin/python

# This script is used to analyze gstack output.
# Author: Nicole Nie (2017/07/18)
#
# Usage: ./parsegstack <gstack_file> [, <out_dir>]
#
# Note:
# 1. The gstack_file should be the path to a stack file generated by gstack command
# 2. The out_dir is current dir if not defined

import os
import operator
import re
import shutil
import string
import sys
import time

def get_stack_uniq_desc(stack):
    desc = ""
    for element in stack:
        desc += element
    return desc

# User input variables.
if not len(sys.argv) == 2 and not len(sys.argv) == 3:
    print "Usage: ./parsegstack <gstack_file> [, <out_dir>]"
    sys.exit(1)

gstack_file = sys.argv[1]
if os.path.isfile(gstack_file):
    gstack_file = os.path.abspath(gstack_file)
else:
    print "Unknown gstack file " + gstack_file
    sys.exit(1)

if len(sys.argv) == 2:
    out_dir = os.getcwd()
else:
    out_dir = sys.argv[2]
    if os.path.isdir(out_dir):
        out_dir = os.path.abspath(out_dir)
    else:
        print "Unknown output directory " + out_dir
        sys.exit(1)
report_file = os.path.join(out_dir, os.path.basename(gstack_file)+".report")

# Open the input gstack file.
stack_dict = {}
with open(gstack_file) as fp:
    thread_key = "Thread 0" # This is not a valid thread
    stack_dict[thread_key] = []
    for i, line in enumerate(fp):
        line = line.rstrip()
        m1 = re.search("^Thread \d+", line) # Thread 1182 (Thread 0x7fcf82098700 (LWP 57206)):
        if m1:
            thread_key = m1.group(0)
            stack_dict[thread_key] = []
            continue

        m2 = re.search("^#\d+ .* in .* at", line) # #1  0x0000000000fa0451 in os_event::wait (this=<optimized out>) at
        if m2:
            start_index = m2.group(0).find("in ")
            end_index = m2.group(0).find(" (", start_index)
            func_name = m2.group(0)[start_index+3:end_index+1]
            stack_dict[thread_key].append(func_name)
            continue

        m3 = re.search("^#\d+ .* at", line) # #2  my_cond_timedwait (abstime=0x7fcf837f3b70, mp=0x1ce5000 <all_groups+214528>, cond=0x7fcf837f3be0) at
        if m3:
            start_index = m3.group(0).find(" ")
            end_index = m3.group(0).find(" (", start_index)
            func_name = m3.group(0)[start_index+1:end_index+1]
            stack_dict[thread_key].append(func_name)

# Reverse the stack dict.
for key, stack in stack_dict.items():
    stack.reverse()

# Generate a report.
desc_dict = {}
report_dict = {}
for key, stack in stack_dict.items():
    if key == "Thread 0":
        continue
    desc = get_stack_uniq_desc(stack)
    if desc in report_dict:
        report_dict[desc] += 1
    else:
        desc_dict[desc] = stack
        report_dict[desc] = 1

sorted_report = sorted(report_dict.iteritems(), key=operator.itemgetter(1), reverse=True)

# Dump the report.
fp = open(report_file, 'w')

for element in sorted_report:
    desc = element[0]
    num_threads = report_dict[desc]
    if num_threads == 1:
        print >> fp, "[ " + str(num_threads) + " thread ]"
    else:
        print >> fp, "[ " + str(num_threads) + " threads ]"
    for i, element in enumerate(desc_dict[desc]):
        if i == 0:
            print >> fp, element.strip()
        else:
            print >> fp, ' '.join("  "*i) + "|-" + element.strip()
    print >> fp

fp.close()
