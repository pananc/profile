#!/usr/bin/python

# This script is used to analyze MySQL general query log.
# Author: Nicole Nie (2017/07/24)
#
# Usage: ./parsequerylog <general_log_file> [, <trx_pattern>, <out_dir>]
#
# Note:
# 1. The general_log_file should be the path to a stack file generated by gstack command
# 2. The trx_pattern is NULL if not defined
# 3. The out_dir is current dir if not defined

import datetime
import os
import operator
import re
import shutil
import string
import sys
import time

def query_type_to_char(type):
    if type == QUERY_BEGIN:
        return "B"
    elif type == QUERY_SELECT:
        return "S"
    elif type == QUERY_INSERT:
        return "I"
    elif type == QUERY_UPDATE:
        return "U"
    elif type == QUERY_DELETE:
        return "D"
    elif type == QUERY_COMMIT:
        return "C"
    else:
        return "/"

# Predefined Query types.
QUERY_UNKNOWN = 0
QUERY_BEGIN = 1
QUERY_SELECT = 2
QUERY_INSERT = 3
QUERY_UPDATE = 4
QUERY_DELETE = 5
QUERY_COMMIT = 6

# Predefined Statement keys.
STMT_TYPE = 1
STMT_TIME = 2

# User input variables.
if not len(sys.argv) == 2 and not len(sys.argv) == 3 and not len(sys.argv) == 4:
    print "Usage: ./parsequerylog <general_log_file> [, <trx_pattern>, <out_dir>]"
    sys.exit(1)

general_log_file = sys.argv[1]
if os.path.isfile(general_log_file):
    general_log_file = os.path.abspath(general_log_file)
else:
    print "Unknown gstack file " + general_log_file
    sys.exit(1)

trx_pattern = ""
if len(sys.argv) == 2:
    out_dir = os.getcwd()
else:
    out_dir = os.getcwd()
    trx_pattern = sys.argv[2]
    if len(sys.argv) == 4:
        out_dir = sys.argv[3]
        if os.path.isdir(out_dir):
            out_dir = os.path.abspath(out_dir)
        else:
            print "Unknown output directory " + out_dir
            sys.exit(1)

report_file = os.path.join(out_dir, os.path.basename(general_log_file)+".report")
# Check if the pattern is valid.
for c in trx_pattern:
    if not c == 'B' and not c == 'S' and not c == 'I' and not c == 'U' and not c == 'D' and not c == 'C':
        print "Transaction pattern can only be one of B(BEGIN), S(SELECT), I(INSERT), U(UPDATE), D(DELETE), C(COMMIT)"
        sys.exit(1)
# Append BEGIN or COMMIT automatically if needed.
if len(trx_pattern) > 0:
    if trx_pattern[0] != 'B':
        trx_pattern = "B" + trx_pattern
    if trx_pattern[-1] != 'C':
        trx_pattern = trx_pattern + "C"

if len(trx_pattern) == 0:
    print "Transaction to match: any"
else:
    print "Transaction to match: " + trx_pattern

# Open the input general query log file.
trx_list = []
trx = []
prev_logtime = datetime.datetime.now()
prev_query_type = QUERY_UNKNOWN
with open(general_log_file) as fp:
    for i, line in enumerate(fp):
        line = line.rstrip()
        m = re.search("^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{6}Z", line) # 2017-07-24T09:02:35.819289Z
        if not m:
            continue
        timestr = m.group(0)
        logtime = datetime.datetime.strptime(timestr, "%Y-%m-%dT%H:%M:%S.%fZ")

        if "Query" in line and "BEGIN" in line:
            query_type = QUERY_BEGIN
            # print "QUERY_BEGIN"
        elif "Query" in line and  "SELECT" in line:
            query_type = QUERY_SELECT
            # print "QUERY_SELECT"
        elif "Query" in line and "INSERT" in line:
            query_type = QUERY_INSERT
            # print "QUERY_INSERT"
        elif "Query" in line and "UPDATE" in line:
            query_type = QUERY_UPDATE
            # print "QUERY_UPDATE"
        elif "Query" in line and "DELETE" in line:
            query_type = QUERY_DELETE
            # print "QUERY_DELETE"
        elif "Query" in line and "COMMIT" in line:
            query_type = QUERY_COMMIT
            # print "QUERY_COMMIT"
        else:
            query_type = QUERY_UNKNOWN
            # print "QUERY_UNKNOWN"

        if prev_query_type != QUERY_UNKNOWN:
            diff = logtime - prev_logtime
            elapsed_us = (diff.days * 86400000000) + (diff.seconds * 1000000) + diff.microseconds
            stmt = {}
            stmt[STMT_TYPE] = prev_query_type
            stmt[STMT_TIME] = elapsed_us
            trx.append(stmt)
            # print "[" + str(i+1) + "] " + line
            # print str(elapsed_us)
        if prev_query_type == QUERY_COMMIT:
            # for stmt in trx:
            #     print query_type_to_char(stmt[STMT_TYPE]) + ": " + str(stmt[STMT_TIME])
            # print
            trx_list.append(trx)
            trx = []

        prev_logtime = logtime
        prev_query_type = query_type

# Go through the trx list.
num_trxs = 0
stmt_usecs = []
if len(trx_pattern) == 0:
    stmt_usecs.append(0)
else:
    for _ in trx_pattern:
        stmt_usecs.append(0)
for trx in trx_list:
    if len(trx_pattern) == 0:
        for stmt in trx:
            stmt_usecs[0] += stmt[STMT_TIME]
        num_trxs += 1
    else:
        pattern = ""
        for stmt in trx:
            pattern += query_type_to_char(stmt[STMT_TYPE])
        # print pattern
        if pattern != trx_pattern:
            continue
        for i, stmt in enumerate(trx):
            stmt_usecs[i] += stmt[STMT_TIME]
        num_trxs += 1

# Dump the report.
fp = open(report_file, 'w')

if len(trx_pattern) == 0:
    print >> fp, "Number of statements inside a transaction: any"
else:
    print >> fp, "Number of statements inside a transaction: " + str(len(trx_pattern))
print >> fp, "Total number of transactions: " + str(num_trxs)
print >> fp
if num_trxs > 0:
    if len(trx_pattern) == 0:
        usec = stmt_usecs[0]
        print >> fp, "ALL"
        print >> fp, "Total elapsed microseconds: " + str(usec)
        print >> fp, "Average elapsed microseconds: " + str(usec/num_trxs)
        print >> fp
    else:
        total_usecs = 0
        for i, usec in enumerate(stmt_usecs):
            total_usecs += usec
            print >> fp, trx_pattern[i] + str(i)
            print >> fp, "Total elapsed microseconds: " + str(usec)
            print >> fp, "Average elapsed microseconds: " + str(usec/num_trxs)
            print >> fp
        print >> fp, "ALL"
        print >> fp, "Total elapsed microseconds: " + str(total_usecs)
        print >> fp, "Average elapsed microseconds: " + str(total_usecs/num_trxs)
        print >> fp

fp.close()
